
/*jshint esversion: 6 */
var https = require('https');
var express = require("express");
var bodyParser = require("body-parser");
var session = require("express-session");
var url = require("url");

const databox = require('node-databox');

//The endpoint for my datastore (Where i can publish my sentiment data)
const DATABOX_STORE_BLOB_ENDPOINT = process.env.DATABOX_APP_TWITTER_SENTIMENT_DATABOX_STORE_BLOB_ENDPOINT || '';

//The endpoint for the datasource requested in the manifest ( env var name derived from the id in the manifest)
var DATASOURCE_DS_twitterUserTimeLine = JSON.parse(process.env.DATASOURCE_DS_twitterUserTimeLine || '{}');
console.log(DATASOURCE_DS_twitterUserTimeLine);
const USER_TIMELINE_ENDPOINT = DATASOURCE_DS_twitterUserTimeLine.href || '';
console.log(USER_TIMELINE_ENDPOINT);

//The endpoint for the datasource requested in the manifest ( env var name derived from the id in the manifest)
var DATASOURCE_DS_twitterHashTagStream = JSON.parse(process.env.DATASOURCE_DS_twitterHashTagStream || '{}');
console.log(DATASOURCE_DS_twitterHashTagStream);
const HASHTAG_ENDPOINT = DATASOURCE_DS_twitterHashTagStream.href || '';
console.log(HASHTAG_ENDPOINT);

//My https cred generated by the container manager
var HTTPS_SERVER_CERT = process.env.HTTPS_SERVER_CERT || '';
var HTTPS_SERVER_PRIVATE_KEY = process.env.HTTPS_SERVER_PRIVATE_KEY || '';
var credentials = {
	key:  HTTPS_SERVER_PRIVATE_KEY,
	cert: HTTPS_SERVER_CERT,
};

var app = express();

var status = "init";
app.get("/status", function(req, res) {
    res.send(status);
});

var latestTweet = "{}";
app.get("/ui", function(req, res) {
    res.send("<h2>" + latestTweet.text + "</h2>");
});

//start the express server
https.createServer(credentials, app).listen(8080);

//
// wait for our datastores to be ready
//
console.log("waiting for DATABOX_STORE_BLOB_ENDPOINT", DATABOX_STORE_BLOB_ENDPOINT),
/*databox.waitForStoreStatus(DATABOX_STORE_BLOB_ENDPOINT,'active')
  .then(() =>{
      
      console.log("waiting for USER_TIMELINE_ENDPOINT", USER_TIMELINE_ENDPOINT);
      return databox.waitForStoreStatus(USER_TIMELINE_ENDPOINT,'active');
      
  })*/
  new Promise((resolve,reject)=>{
    setTimeout(resolve,10000);
  })
  .then(() =>{

      //let everyone know that I'm ready
      status = "active";

      //Register my sentiment datasource with my store to make it available to other apps
      console.log("Registering sentiment datasource");
      proms = [
          databox.catalog.registerDatasource(DATABOX_STORE_BLOB_ENDPOINT, {
                description: 'Twitter user timeline sentiment',
                contentType: 'text/json',
                vendor: 'Databox Inc.',
                type: 'twitterUserTimelineSentiment',
                datasourceid: 'twitterUserTimelineSentiment',
                storeType: 'databox-store-blob',
            }),
            databox.catalog.registerDatasource(DATABOX_STORE_BLOB_ENDPOINT, {
                description: 'Twitter hash tag sentiment',
                contentType: 'text/json',
                vendor: 'Databox Inc.',
                type: 'twitterHashTagSentiment',
                datasourceid: 'twitterHashTagSentiment',
                storeType: 'databox-store-blob',
            })
      ];
    return Promise.all(proms);

  })
  .then(()=>{

      //register for live streaming data from the databox-driver-twitter-stream
      console.log("subscribing to datasources:", USER_TIMELINE_ENDPOINT, HASHTAG_ENDPOINT);

      var dataEmitter = null; 

      if(USER_TIMELINE_ENDPOINT !== '') {

        var endpointUrl = url.parse(USER_TIMELINE_ENDPOINT);
        var dsID = DATASOURCE_DS_twitterUserTimeLine['item-metadata'].filter((itm)=>{return itm.rel === 'urn:X-databox:rels:hasDatasourceid'; })[0].val;
        var dsUrl = endpointUrl.protocol + '//' + endpointUrl.host;
        var dsType = DATASOURCE_DS_twitterUserTimeLine['item-metadata'].filter((itm)=>{return itm.rel === 'urn:X-databox:rels:hasType';})[0].val;
        databox.timeseries.latest(dsUrl, dsID)
        .then((data)=>{
            console.log(data);
            latestTweet = data[0].data;
        })
        .catch((err)=>{
            console.log("[Error getting timeseries.latest]",dsUrl, dsID);
        });

        databox.subscriptions.connect(USER_TIMELINE_ENDPOINT)
        .then((emitter)=>{
            dataEmitter = emitter;      


            var endpointUrl = url.parse(USER_TIMELINE_ENDPOINT);
            var dsID = DATASOURCE_DS_twitterUserTimeLine['item-metadata'].filter((itm)=>{return itm.rel === 'urn:X-databox:rels:hasDatasourceid'; })[0].val;
            var dsUrl = endpointUrl.protocol + '//' + endpointUrl.host;
            console.log("[subscribing]",dsUrl,dsID);
            databox.subscriptions.subscribe(dsUrl,dsID,'ts')
            .catch((err)=>{console.log("[ERROR subscribing]",err)});

            endpointUrl = url.parse(HASHTAG_ENDPOINT);
            dsID = DATASOURCE_DS_twitterHashTagStream['item-metadata'].filter((itm)=>{return itm.rel === 'urn:X-databox:rels:hasDatasourceid'; })[0].val;
            dsUrl = endpointUrl.protocol + '//' + endpointUrl.host;
            console.log("[subscribing]",dsUrl,dsID);
            databox.subscriptions.subscribe(dsUrl,dsID,'ts')
            .catch((err)=>{console.log("[ERROR subscribing]",err)});

            dataEmitter.on('data',(hostname, dsID, data)=>{
                console.log(hostname, dsID, data);
                latestTweet = data;
            });

            dataEmitter.on('error',(error)=>{
                console.log(error);
            });

        })
        .catch((err)=>{console.log("[Error] connecting ws endpoint ",err);});
      }
  })
  .catch((error)=>{
      status="error";
      console.log("[ERROR]",error);
  });

module.exports = app;
